// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

// ================== Interfaces ==================
interface AggregatorV3Interface {
    function latestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );
}

interface IUniswapV2Router02 {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

interface IUniswapV3Router {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    function exactInputSingle(ExactInputSingleParams calldata params) external returns (uint256 amountOut);
}

interface IBalancerVault {
    enum SwapKind { GIVEN_IN, GIVEN_OUT }

    struct SingleSwap {
        bytes32 poolId;
        SwapKind kind;
        address assetIn;
        address assetOut;
        uint256 amount;
        bytes userData;
    }

    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address payable recipient;
        bool toInternalBalance;
    }

    function swap(
        SingleSwap calldata singleSwap,
        FundManagement calldata funds,
        uint256 limit,
        uint256 deadline
    ) external returns (uint256 amountCalculated);
}

interface IAAVEPool {
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata modes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

// ================== Contract ==================
contract ImprovedArbitrageBot is ReentrancyGuard, Pausable, Ownable {
    using SafeERC20 for IERC20;

    // ==================== CONSTANTS ====================
    address public constant UNISWAP_V2_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    address public constant UNISWAP_V3_ROUTER = 0xE592427A0AEce92De3Edee1F18E0157C05861564;
    address public constant SUSHISWAP_ROUTER = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;
    address public constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address public constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;

    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address public constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;

    uint256 public constant MAX_SLIPPAGE_BPS = 500; // 5%
    uint256 public constant MAX_TRADE_AMOUNT = 100 ether;
    uint256 public constant MIN_PROFIT_THRESHOLD = 0.001 ether;
    uint256 public constant FLASH_LOAN_COOLDOWN = 60; // 1 min
    uint256 public constant DAILY_FLASH_LOAN_LIMIT = 50;

    // ==================== STRUCTS ====================
    struct DEXInfo {
        address router;
        string name;
        uint256 feeBps;
        uint8 dexType; // 0: V2, 1: V3, 2: Sushiswap, 3: Balancer
    }

    struct ArbitrageParams {
        address tokenIn;
        address tokenOut;
        uint256 amountIn;
        uint256 minAmountOut;
        uint8 dexIn;
        uint8 dexOut;
        uint24 uniV3Fee;
        bytes32 balancerPoolId;
        uint256 deadline;
    }

    struct Opportunity {
        uint8 dexIn;
        uint8 dexOut;
        uint256 expectedProfit;
        uint256 minProfit;
        uint256 gasEstimate;
        bool isValid;
    }

    // ==================== STATE VARIABLES ====================
    DEXInfo[4] public dexConfigs;
    mapping(bytes32 => bool) public validBalancerPools;
    mapping(address => bool) public supportedTokens;
    mapping(address => uint256) public lastFlashLoan;
    mapping(address => uint256) public dailyFlashLoanCount;
    mapping(address => uint256) public lastDailyReset;

    uint256 public totalTrades;
    uint256 public totalVolume;
    bool public preferPrivateSubmission;

    mapping(address => address) public priceFeedsUSD;
    address public CHAINLINK_ETH_USD;

    // ==================== EVENTS ====================
    event ArbitrageExecuted(
        address indexed user,
        address indexed tokenIn,
        address indexed tokenOut,
        uint256 amountIn,
        uint256 profit,
        uint8 dexIn,
        uint8 dexOut
    );

    // ==================== CONSTRUCTOR ====================
    constructor(address initialOwner) {
        _transferOwnership(initialOwner);

        dexConfigs[0] = DEXInfo(UNISWAP_V2_ROUTER, "Uniswap V2", 300, 0);
        dexConfigs[1] = DEXInfo(SUSHISWAP_ROUTER, "Sushiswap", 300, 2);
        dexConfigs[2] = DEXInfo(UNISWAP_V3_ROUTER, "Uniswap V3", 500, 1);
        dexConfigs[3] = DEXInfo(BALANCER_VAULT, "Balancer", 100, 3);

        // Example supported tokens
        supportedTokens[WETH] = true;
        supportedTokens[USDC] = true;
        supportedTokens[USDT] = true;
        supportedTokens[DAI] = true;
        supportedTokens[WBTC] = true;
    }

    // ==================== Chainlink Price Feed Helpers ====================
    function setPriceFeed(address token, address feed) external onlyOwner {
        priceFeedsUSD[token] = feed;
    }

    function setChainlinkEthUsd(address feed) external onlyOwner {
        CHAINLINK_ETH_USD = feed;
    }

    function _latestAnswer(address feed) internal view returns (uint256) {
        require(feed != address(0), "no feed");
        (, int256 answer, , ,) = AggregatorV3Interface(feed).latestRoundData();
        require(answer > 0, "bad feed value");
        return uint256(answer);
    }

    // ==================== Arbitrage Logic ====================
    function _executeArbitrage(ArbitrageParams memory params) internal {
        uint256 intermediate = _executeTrade(
            params.tokenIn,
            params.tokenOut,
            params.amountIn,
            0,
            params.dexIn,
            params.uniV3Fee,
            params.balancerPoolId,
            params.deadline
        );

        require(intermediate > 0, "First trade failed");

        uint256 finalAmount = _executeTrade(
            params.tokenOut,
            params.tokenIn,
            intermediate,
            params.minAmountOut,
            params.dexOut,
            params.uniV3Fee,
            params.balancerPoolId,
            params.deadline
        );

        require(finalAmount >= params.minAmountOut, "Insufficient output");
    }

    function _executeTrade(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 minAmountOut,
        uint8 dexId,
        uint24 uniV3Fee,
        bytes32 balancerPoolId,
        uint256 deadline
    ) internal returns (uint256) {
        DEXInfo memory d = dexConfigs[dexId];

        if (d.dexType == 0 || d.dexType == 2) { // V2/Sushi
            IERC20(tokenIn).safeApprove(d.router, 0);
            IERC20(tokenIn).safeApprove(d.router, amountIn);
            address ;
            path[0] = tokenIn;
            path[1] = tokenOut;
            uint256[] memory amounts = IUniswapV2Router02(d.router).swapExactTokensForTokens(
                amountIn,
                minAmountOut,
                path,
                address(this),
                deadline
            );
            return amounts[1];
        } else if (d.dexType == 1) { // V3
            IERC20(tokenIn).safeApprove(d.router, 0);
            IERC20(tokenIn).safeApprove(d.router, amountIn);
            IUniswapV3Router.ExactInputSingleParams memory p = IUniswapV3Router.ExactInputSingleParams({
                tokenIn: tokenIn,
                tokenOut: tokenOut,
                fee: uniV3Fee,
                recipient: address(this),
                deadline: deadline,
                amountIn: amountIn,
                amountOutMinimum: minAmountOut,
                sqrtPriceLimitX96: 0
            });
            return IUniswapV3Router(d.router).exactInputSingle(p);
        } else if (d.dexType == 3) { // Balancer
            require(validBalancerPools[balancerPoolId], "Invalid pool");
            IERC20(tokenIn).safeApprove(d.router, 0);
            IERC20(tokenIn).safeApprove(d.router, amountIn);
            IBalancerVault.SingleSwap memory swap = IBalancerVault.SingleSwap({
                poolId: balancerPoolId,
                kind: IBalancerVault.SwapKind.GIVEN_IN,
                assetIn: tokenIn,
                assetOut: tokenOut,
                amount: amountIn,
                userData: ""
            });
            IBalancerVault.FundManagement memory funds = IBalancerVault.FundManagement({
                sender: address(this),
                fromInternalBalance: false,
                recipient: payable(address(this)),
                toInternalBalance: false
            });
            return IBalancerVault(d.router).swap(swap, funds, minAmountOut, deadline);
        }
        revert("Invalid DEX");
    }
}
