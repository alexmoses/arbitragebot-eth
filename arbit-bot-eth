// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

/**
 * @title Improved Arbitrage Bot
 * @notice This contract finds and executes arbitrage opportunities across multiple DEXes using flash loans.
 * @dev Includes security improvements, dynamic slippage, and emergency stop.
 *      This version upgrades Balancer quoting using Vault.queryBatchSwap (single-hop) and
 *      adds an off-chain preference flag for private/bundled submission (documentational only).
 *      For multi-hop Balancer routes, prefer off-chain SOR -> on-chain execution (see notes in code).
 */
contract ImprovedArbitrageBot is ReentrancyGuard, Pausable, Ownable {
    using SafeERC20 for IERC20;

    // ==================== CONSTANTS ====================
    address public constant UNISWAP_V2_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    address public constant UNISWAP_V3_ROUTER = 0xE592427A0AEce92De3Edee1F18E0157C05861564;
    address public constant SUSHISWAP_ROUTER = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;
    address public constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address public constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;

    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address public constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;

    uint256 public constant MAX_SLIPPAGE_BPS = 500; // 5% in basis points
    uint256 public constant MAX_TRADE_AMOUNT = 100 ether;
    uint256 public constant MIN_PROFIT_THRESHOLD = 0.001 ether;
    uint256 public constant FLASH_LOAN_COOLDOWN = 60; // 1 minute
    uint256 public constant DAILY_FLASH_LOAN_LIMIT = 50;

    // ==================== STRUCTS ====================
    struct DEXInfo {
        address router;
        string name;
        uint256 feeBps; // Fee in basis points
        uint8 dexType; // 0: UniswapV2, 1: UniswapV3, 2: Sushiswap, 3: Balancer
    }

    struct ArbitrageParams {
        address tokenIn;
        address tokenOut;
        uint256 amountIn;
        uint256 minAmountOut;
        uint8 dexIn;
        uint8 dexOut;
        uint24 uniV3Fee;
        bytes32 balancerPoolId;
        uint256 deadline;
    }

    struct Opportunity {
        uint8 dexIn;
        uint8 dexOut;
        uint256 expectedProfit;
        uint256 minProfit;
        uint256 gasEstimate;
        bool isValid;
    }

    // ==================== STATE VARIABLES ====================
    DEXInfo[4] public dexConfigs;
    mapping(bytes32 => bool) public validBalancerPools;
    mapping(address => bool) public supportedTokens;
    mapping(address => uint256) public lastFlashLoan;
    mapping(address => uint256) public dailyFlashLoanCount;
    mapping(address => uint256) public lastDailyReset;

    uint256 public totalTrades;
    uint256 public totalVolume;

    // Optional, informational only: allows off-chain systems to record preference
    bool public preferPrivateSubmission; // e.g., Flashbots/bundles

    // ----------------- Chainlink price feeds (for gas-aware profitability checks) -----------------
    // token => USD price feed (Chainlink)
    mapping(address => address) public priceFeedsUSD;
    // ETH/USD feed address
    address public CHAINLINK_ETH_USD;

    /// @notice Owner registers a Chainlink USD price feed for a token
    function setPriceFeed(address token, address feed) external onlyOwner {
        priceFeedsUSD[token] = feed;
    }

    /// @notice Owner sets the ETH/USD feed (required to convert gas cost to token units)
    function setChainlinkEthUsd(address feed) external onlyOwner {
        CHAINLINK_ETH_USD = feed;
    }

    function _latestAnswer(address feed) internal view returns (uint256) {
        require(feed != address(0), "no feed");
        (, int256 answer, , ,) = AggregatorV3Interface(feed).latestRoundData();
        require(answer > 0, "bad feed value");
        return uint256(answer);
    }

    /**
     * @notice Check whether an expected gross profit (in token units) remains profitable after
     * estimated gas cost, flash-loan fee and a safety margin. This should be called with
     * gas estimates obtained off-chain (eth_estimateGas) and an intended gas price.
     * @param tokenIn token used for profit accounting
     * @param expectedProfitTokenIn gross expected profit in token units (final - initial)
     * @param gasUnitsEstimate estimated gas units for the full transaction
     * @param gasPriceWei gas price in wei (use 1559 effective priority fee if preferred)
     * @param flashLoanFeeBps flash-loan fee in basis points (e.g. 5 = 0.05%)
     * @param safetyMarginBps safety buffer in bps (e.g. 200 = 2%)
     */
    function isProfitableAfterCosts(
        address tokenIn,
        uint256 expectedProfitTokenIn,
        uint256 gasUnitsEstimate,
        uint256 gasPriceWei,
        uint256 flashLoanFeeBps,
        uint256 safetyMarginBps
    ) public view returns (bool, uint256 netProfitTokenIn) {
        address tokenFeed = priceFeedsUSD[tokenIn];
        require(tokenFeed != address(0), "missing token feed");
        require(CHAINLINK_ETH_USD != address(0), "missing eth feed");

        uint256 ethPrice = _latestAnswer(CHAINLINK_ETH_USD); // e.g., 8 decimals
        uint256 tokenPrice = _latestAnswer(tokenFeed);      // same decimals

        uint256 gasCostWei = gasUnitsEstimate * gasPriceWei;

        // Convert gasCostWei (wei) to token units:
        // gasCostToken = (gasCostWei * ethPrice) / (tokenPrice * 1e18)
        uint256 gasCostToken = (gasCostWei * ethPrice) / (tokenPrice * 1e18);

        uint256 flashFeeToken = (expectedProfitTokenIn * flashLoanFeeBps) / 10000;
        uint256 safety = (expectedProfitTokenIn * safetyMarginBps) / 10000;

        if (expectedProfitTokenIn <= gasCostToken + flashFeeToken + safety) {
            return (false, 0);
        }
        netProfitTokenIn = expectedProfitTokenIn - gasCostToken - flashFeeToken - safety;
        return (true, netProfitTokenIn);
    }

    // ==================== EVENTS ====================
    event ArbitrageExecuted(
        address indexed user,
        address indexed tokenIn,
        address indexed tokenOut,
        uint256 amountIn,
        uint256 profit,
        uint8 dexIn,
        uint8 dexOut
    );

    event OpportunityFound(
        address indexed tokenA,
        address indexed tokenB,
        uint256 amount,
        uint256 expectedProfit,
        uint8 dexIn,
        uint8 dexOut
    );

    event EmergencyStop(bool stopped);
    event SlippageAdjusted(uint256 newSlippageBps);
    event PrivateTxPreferenceSet(bool enabled);

    // ==================== MODIFIERS ====================
    modifier validTokens(address tokenA, address tokenB) {
        require(tokenA != address(0) && tokenB != address(0), "Invalid tokens");
        require(tokenA != tokenB, "Same tokens");
        require(supportedTokens[tokenA] && supportedTokens[tokenB], "Unsupported tokens");
        _;
    }

    modifier rateLimited() {
        if (block.timestamp > lastDailyReset[msg.sender] + 1 days) {
            dailyFlashLoanCount[msg.sender] = 0;
            lastDailyReset[msg.sender] = block.timestamp;
        }
        require(block.timestamp >= lastFlashLoan[msg.sender] + FLASH_LOAN_COOLDOWN, "Flash loan cooldown");
        require(dailyFlashLoanCount[msg.sender] < DAILY_FLASH_LOAN_LIMIT, "Daily limit exceeded");
        _;
        lastFlashLoan[msg.sender] = block.timestamp;
        dailyFlashLoanCount[msg.sender]++;
    }

    // ==================== CONSTRUCTOR ====================
    constructor() {
        // Initialize DEX configurations
        dexConfigs[0] = DEXInfo(UNISWAP_V2_ROUTER, "Uniswap V2", 300, 0);
        dexConfigs[1] = DEXInfo(SUSHISWAP_ROUTER, "Sushiswap", 300, 2);
        dexConfigs[2] = DEXInfo(UNISWAP_V3_ROUTER, "Uniswap V3", 500, 1);
        dexConfigs[3] = DEXInfo(BALANCER_VAULT, "Balancer", 100, 3);

        // Set valid Balancer pools (examples)
        validBalancerPools[0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014] = true;
        validBalancerPools[0x96646936b91d6b9d7d0c47c496afbf3d6ec7b6f8000200000000000000000019] = true;
        validBalancerPools[0x0b09dea16768f0799065c475be02919503cb2a3500020000000000000000001a] = true;

        // Supported tokens
        supportedTokens[WETH] = true;
        supportedTokens[USDC] = true;
        supportedTokens[USDT] = true;
        supportedTokens[DAI] = true;
        supportedTokens[WBTC] = true;
    }

    // ==================== MAIN FUNCTIONS ====================
    function findOpportunity(uint256 maxAmount) external view whenNotPaused
        returns (Opportunity memory bestOpportunity, address tokenA, address tokenB, uint256 amount)
    {
        require(maxAmount > 0 && maxAmount <= MAX_TRADE_AMOUNT, "Invalid amount");
        address[] memory tokens = new address[](5);
        tokens[0] = WETH;
        tokens[1] = USDC;
        tokens[2] = USDT;
        tokens[3] = DAI;
        tokens[4] = WBTC;

        uint256 maxProfit = 0;
        for (uint i = 0; i < tokens.length; i++) {
            for (uint j = 0; j < tokens.length; j++) {
                if (i == j) continue;
                if (!supportedTokens[tokens[i]] || !supportedTokens[tokens[j]]) continue;
                uint256[] memory amounts = new uint256[](3);
                amounts[0] = maxAmount / 10;
                amounts[1] = maxAmount / 4;
                amounts[2] = maxAmount / 2;
                for (uint k = 0; k < amounts.length; k++) {
                    Opportunity memory opp = _findOpportunity(tokens[i], tokens[j], amounts[k]);
                    if (opp.isValid && opp.expectedProfit > maxProfit) {
                        maxProfit = opp.expectedProfit;
                        bestOpportunity = opp;
                        tokenA = tokens[i];
                        tokenB = tokens[j];
                        amount = amounts[k];
                    }
                }
            }
        }
    }

    function executeArbitrage(uint256 maxAmount) external nonReentrant whenNotPaused rateLimited {
        require(maxAmount > 0 && maxAmount <= MAX_TRADE_AMOUNT, "Invalid amount");
        (Opportunity memory opportunity, address tokenA, address tokenB, uint256 bestAmount) = this.findOpportunity(maxAmount);
        require(opportunity.isValid, "No opportunity found");
        require(opportunity.expectedProfit >= MIN_PROFIT_THRESHOLD, "Profit too low");

        ArbitrageParams memory params = ArbitrageParams({
            tokenIn: tokenA,
            tokenOut: tokenB,
            amountIn: bestAmount,
            minAmountOut: opportunity.minProfit,
            dexIn: opportunity.dexIn,
            dexOut: opportunity.dexOut,
            uniV3Fee: 3000,
            balancerPoolId: _getBalancerPoolId(tokenA, tokenB),
            deadline: block.timestamp + 300
        });

        _executeFlashLoan(params);
    }

    function withdraw(uint256 amount) external nonReentrant {
        require(amount > 0, "Invalid amount");
        IERC20(WETH).safeTransferFrom(msg.sender, address(this), amount);
        IWETH(WETH).withdraw(amount);
        payable(msg.sender).transfer(amount);
    }

    function emergencyStop() external onlyOwner {
        _pause();
        emit EmergencyStop(true);
    }

    function resume() external onlyOwner {
        _unpause();
        emit EmergencyStop(false);
    }

    function setPreferPrivateSubmission(bool enabled) external onlyOwner {
        preferPrivateSubmission = enabled;
        emit PrivateTxPreferenceSet(enabled);
    }

    // ==================== INTERNAL FUNCTIONS ====================
    function _findOpportunity(address tokenA, address tokenB, uint256 amountIn) internal view
        returns (Opportunity memory bestOpportunity)
    {
        uint256 maxProfit = 0;
        for (uint8 i = 0; i < 4; i++) {
            for (uint8 j = 0; j < 4; j++) {
                if (i == j) continue;
                uint256 profit = _calculateProfit(tokenA, tokenB, amountIn, i, j);
                if (profit > maxProfit) {
                    maxProfit = profit;
                    bestOpportunity = Opportunity({
                        dexIn: i,
                        dexOut: j,
                        expectedProfit: profit,
                        minProfit: (profit * (10000 - MAX_SLIPPAGE_BPS)) / 10000,
                        gasEstimate: _estimateGasCost(i, j),
                        isValid: profit > 0
                    });
                }
            }
        }
    }

    function _calculateProfit(address tokenA, address tokenB, uint256 amountIn, uint8 dexIn, uint8 dexOut) internal view returns (uint256) {
        uint256 intermediateAmount = _getExpectedAmountOut(tokenA, tokenB, amountIn, dexIn);
        if (intermediateAmount == 0) return 0;
        uint256 finalAmount = _getExpectedAmountOut(tokenB, tokenA, intermediateAmount, dexOut);
        if (finalAmount <= amountIn) return 0;
        return finalAmount - amountIn;
    }

    function _getExpectedAmountOut(address tokenIn, address tokenOut, uint256 amountIn, uint8 dexId) internal view returns (uint256) {
        DEXInfo memory d = dexConfigs[dexId];
        if (d.dexType == 0 || d.dexType == 2) {
            address[] memory path = new address[](2);
            path[0] = tokenIn;
            path[1] = tokenOut;
            try IUniswapV2Router02(d.router).getAmountsOut(amountIn, path) returns (uint[] memory amounts) {
                return amounts[1];
            } catch {
                return 0;
            }
        } else if (d.dexType == 1) {
            return _getUniswapV3Quote(tokenIn, tokenOut, amountIn, uint24(d.feeBps));
        } else if (d.dexType == 3) {
            bytes32 poolId = _getBalancerPoolId(tokenIn, tokenOut);
            return _getBalancerQuote(tokenIn, tokenOut, amountIn, poolId);
        }
        return 0;
    }

    function _getUniswapV3Quote(address tokenIn, address tokenOut, uint256 amountIn, uint24 /*fee*/) internal view returns (uint256) {
        // Placeholder: integrate IQuoterV2 for precise quotes in production
        return amountIn; // DO NOT USE IN PROD
    }

    /// @dev Accurate single-hop Balancer quote via Vault.queryBatchSwap (staticcall). Returns amountOut.
    function _getBalancerQuote(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        bytes32 poolId
    ) internal view returns (uint256) {
        if (poolId == bytes32(0) || !validBalancerPools[poolId]) return 0;

        IBalancerVaultQuery.BatchSwapStep[] memory steps = new IBalancerVaultQuery.BatchSwapStep[](1);
        steps[0] = IBalancerVaultQuery.BatchSwapStep({
            poolId: poolId,
            assetInIndex: 0,
            assetOutIndex: 1,
            amount: amountIn,
            userData: ""
        });

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(tokenIn));
        assets[1] = IAsset(address(tokenOut));

        IBalancerVaultQuery.FundManagement memory funds = IBalancerVaultQuery.FundManagement({
            sender: address(this),
            fromInternalBalance: false,
            recipient: payable(address(this)),
            toInternalBalance: false
        });

        try IBalancerVaultQuery(BALANCER_VAULT).queryBatchSwap(
            IBalancerVaultQuery.SwapKind.GIVEN_IN,
            steps,
            assets,
            funds
        ) returns (int256[] memory deltas) {
            // Balancer sign convention: negative => tokens sent by caller, positive => tokens received by caller
            int256 outDelta = deltas[1];
            if (outDelta < 0) outDelta = -outDelta;
            return uint256(outDelta);
        } catch {
            return 0;
        }
    }

    function _estimateGasCost(uint8 dexIn, uint8 dexOut) internal pure returns (uint256) {
        uint256 gasIn = 150000;
        uint256 gasOut = 150000;
        if (dexIn == 1) gasIn = 180000;
        if (dexOut == 1) gasOut = 180000;
        if (dexIn == 3) gasIn = 200000;
        if (dexOut == 3) gasOut = 200000;
        return gasIn + gasOut;
    }

    function _getBalancerPoolId(address tokenA, address tokenB) internal view returns (bytes32) {
        if ((tokenA == WETH && tokenB == USDC) || (tokenA == USDC && tokenB == WETH)) {
            return 0x96646936b91d6b9d7d0c47c496afbf3d6ec7b6f8000200000000000000000019;
        }
        if ((tokenA == WETH && tokenB == DAI) || (tokenA == DAI && tokenB == WETH)) {
            return 0x0b09dea16768f0799065c475be02919503cb2a3500020000000000000000001a;
        }
        return bytes32(0);
    }

    function executeArbitrageWithEstimates(
        uint256 maxAmount,
        uint256 gasUnitsEstimate,
        uint256 gasPriceWei,
        uint256 flashLoanFeeBps,
        uint256 safetyMarginBps
    ) external nonReentrant whenNotPaused rateLimited {
        require(maxAmount > 0 && maxAmount <= MAX_TRADE_AMOUNT, "Invalid amount");
        (Opportunity memory opportunity, address tokenA, address tokenB, uint256 bestAmount) = this.findOpportunity(maxAmount);
        require(opportunity.isValid, "No opportunity found");
        require(opportunity.expectedProfit >= MIN_PROFIT_THRESHOLD, "Profit too low");

        // On-chain safety check using Chainlink feeds and off-chain gas estimate
        (bool ok, uint256 net) = isProfitableAfterCosts(tokenA, opportunity.expectedProfit, gasUnitsEstimate, gasPriceWei, flashLoanFeeBps, safetyMarginBps);
        require(ok, "Not profitable after costs");

        ArbitrageParams memory params = ArbitrageParams({
            tokenIn: tokenA,
            tokenOut: tokenB,
            amountIn: bestAmount,
            minAmountOut: opportunity.minProfit,
            dexIn: opportunity.dexIn,
            dexOut: opportunity.dexOut,
            uniV3Fee: 3000,
            balancerPoolId: _getBalancerPoolId(tokenA, tokenB),
            deadline: block.timestamp + 300
        });

        _executeFlashLoan(params);
    }

    function _executeFlashLoan(ArbitrageParams memory params) internal {
        address[] memory assets = new address[](1);
        assets[0] = params.tokenIn;
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = params.amountIn;
        uint256[] memory modes = new uint256[](1);
        modes[0] = 0;
        bytes memory data = abi.encode(params);
        IAAVEPool(AAVE_POOL).flashLoan(address(this), assets, amounts, modes, address(this), data, 0);
    }

    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    ) external returns (bool) {
        require(msg.sender == AAVE_POOL, "Invalid caller");
        require(initiator == address(this), "Invalid initiator");
        ArbitrageParams memory arbParams = abi.decode(params, (ArbitrageParams));
        address tokenIn = assets[0];
        uint256 amount = amounts[0];
        uint256 premium = premiums[0];
        uint256 balanceBefore = IERC20(tokenIn).balanceOf(address(this));
        _executeArbitrage(arbParams);
        uint256 balanceAfter = IERC20(tokenIn).balanceOf(address(this));
        uint256 totalDebt = amount + premium;
        require(balanceAfter >= totalDebt, "Insufficient profit");
        IERC20(tokenIn).safeApprove(AAVE_POOL, 0);
        IERC20(tokenIn).safeApprove(AAVE_POOL, totalDebt);
        uint256 profit = balanceAfter - totalDebt;
        if (profit > 0) {
            IERC20(tokenIn).safeTransfer(msg.sender, profit); // NOTE: original behavior sends to caller; consider pull model in production
        }
        totalTrades++;
        totalVolume += amount;
        emit ArbitrageExecuted(msg.sender, arbParams.tokenIn, arbParams.tokenOut, amount, profit, arbParams.dexIn, arbParams.dexOut);
        return true;
    }

    function _executeArbitrage(ArbitrageParams memory params) internal {
        uint256 intermediateAmount = _executeTrade(params.tokenIn, params.tokenOut, params.amountIn, 0, params.dexIn, params.uniV3Fee, params.balancerPoolId, params.deadline);
        require(intermediateAmount > 0, "First trade failed");
        uint256 finalAmount = _executeTrade(params.tokenOut, params.tokenIn, intermediateAmount, params.minAmountOut, params.dexOut, params.uniV3Fee, params.balancerPoolId, params.deadline);
        require(finalAmount >= params.minAmountOut, "Insufficient output");
    }

    function _executeTrade(address tokenIn, address tokenOut, uint256 amountIn, uint256 minAmountOut, uint8 dexId, uint24 uniV3Fee, bytes32 balancerPoolId, uint256 deadline) internal returns (uint256) {
        DEXInfo memory d = dexConfigs[dexId];
        if (d.dexType == 0 || d.dexType == 2) {
            return _executeV2Trade(tokenIn, tokenOut, amountIn, minAmountOut, d.router, deadline);
        } else if (d.dexType == 1) {
            return _executeV3Trade(tokenIn, tokenOut, amountIn, minAmountOut, uniV3Fee, deadline);
        } else if (d.dexType == 3) {
            return _executeBalancerTrade(tokenIn, tokenOut, amountIn, minAmountOut, balancerPoolId, deadline);
        }
        revert("Invalid DEX");
    }

    function _executeV2Trade(address tokenIn, address tokenOut, uint256 amountIn, uint256 minAmountOut, address router, uint256 deadline) internal returns (uint256) {
        IERC20(tokenIn).safeApprove(router, 0);
        IERC20(tokenIn).safeApprove(router, amountIn);
        address[] memory path = new address[](2);
        path[0] = tokenIn;
        path[1] = tokenOut;
        uint256[] memory amounts = IUniswapV2Router02(router).swapExactTokensForTokens(amountIn, minAmountOut, path, address(this), deadline);
        return amounts[1];
    }

    function _executeV3Trade(address tokenIn, address tokenOut, uint256 amountIn, uint256 minAmountOut, uint24 fee, uint256 deadline) internal returns (uint256) {
        IERC20(tokenIn).safeApprove(UNISWAP_V3_ROUTER, 0);
        IERC20(tokenIn).safeApprove(UNISWAP_V3_ROUTER, amountIn);
        IUniswapV3Router.ExactInputSingleParams memory p = IUniswapV3Router.ExactInputSingleParams({
            tokenIn: tokenIn,
            tokenOut: tokenOut,
            fee: fee,
            recipient: address(this),
            deadline: deadline,
            amountIn: amountIn,
            amountOutMinimum: minAmountOut,
            sqrtPriceLimitX96: 0
        });
        return IUniswapV3Router(UNISWAP_V3_ROUTER).exactInputSingle(p);
    }

    function _executeBalancerTrade(address tokenIn, address tokenOut, uint256 amountIn, uint256 minAmountOut, bytes32 poolId, uint256 deadline) internal returns (uint256) {
        require(validBalancerPools[poolId], "Invalid pool");
        IERC20(tokenIn).safeApprove(BALANCER_VAULT, 0);
        IERC20(tokenIn).safeApprove(BALANCER_VAULT, amountIn);
        IBalancerVault.SingleSwap memory singleSwap = IBalancerVault.SingleSwap({
            poolId: poolId,
            kind: IBalancerVault.SwapKind.GIVEN_IN,
            assetIn: tokenIn,
            assetOut: tokenOut,
            amount: amountIn,
            userData: ""
        });
        IBalancerVault.FundManagement memory funds = IBalancerVault.FundManagement({
            sender: address(this),
            fromInternalBalance: false,
            recipient: payable(address(this)),
            toInternalBalance: false
        });
        return IBalancerVault(BALANCER_VAULT).swap(singleSwap, funds, minAmountOut, deadline);
    }

    // ==================== FALLBACK ====================
    receive() external payable {}
}

// ==================== INTERFACES ====================
interface IUniswapV2Router02 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);
}

interface IUniswapV3Router {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }
    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);
}

interface IBalancerVault {
    enum SwapKind { GIVEN_IN, GIVEN_OUT }
    struct SingleSwap {
        bytes32 poolId;
        SwapKind kind;
        address assetIn;
        address assetOut;
        uint256 amount;
        bytes userData;
    }
    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address payable recipient;
        bool toInternalBalance;
    }
    function swap(SingleSwap memory singleSwap, FundManagement memory funds, uint256 limit, uint256 deadline) external returns (uint256);
}

// Minimal Balancer query interface to use queryBatchSwap without changing the existing IBalancerVault
interface IBalancerVaultQuery {
    enum SwapKind { GIVEN_IN, GIVEN_OUT }
    struct BatchSwapStep {
        bytes32 poolId;
        uint256 assetInIndex;
        uint256 assetOutIndex;
        uint256 amount;
        bytes userData;
    }
    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address payable recipient;
        bool toInternalBalance;
    }
    function queryBatchSwap(
        SwapKind kind,
        BatchSwapStep[] memory swaps,
        IAsset[] memory assets,
        FundManagement memory funds
    ) external returns (int256[] memory assetDeltas);
}

// Balancer treats ERC20s as IAsset in the Vault API
interface IAsset {}

interface IAAVEPool {
    function flashLoan(
        address receiverAddress,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata modes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

interface IWETH {
    function deposit() external payable;
    function withdraw(uint256 amount) external;
}

// Chainlink Aggregator interface (minimal)
interface AggregatorV3Interface {
    function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80);
    function decimals() external view returns (uint8);
}
