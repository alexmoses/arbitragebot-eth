// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

// Define the interface at the file level
interface AggregatorV3Interface {
    function latestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        );
}
/**
 * @title Improved Arbitrage Bot
 * @notice This contract finds and executes arbitrage opportunities across multiple DEXes using flash loans.
 * @dev Includes security improvements, dynamic slippage, and emergency stop.
 *      This version upgrades Balancer quoting using Vault.queryBatchSwap (single-hop) and
 *      adds an off-chain preference flag for private/bundled submission (documentational only).
 *      For multi-hop Balancer routes, prefer off-chain SOR -> on-chain execution (see notes in code).
 */
contract ImprovedArbitrageBot is ReentrancyGuard, Pausable, Ownable {
    using SafeERC20 for IERC20;

    // ==================== CONSTANTS ====================
    address public constant UNISWAP_V2_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    address public constant UNISWAP_V3_ROUTER = 0xE592427A0AEce92De3Edee1F18E0157C05861564;
    address public constant SUSHISWAP_ROUTER = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;
    address public constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address public constant AAVE_POOL = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;

    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address public constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address public constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;

    uint256 public constant MAX_SLIPPAGE_BPS = 500; // 5% in basis points
    uint256 public constant MAX_TRADE_AMOUNT = 100 ether;
    uint256 public constant MIN_PROFIT_THRESHOLD = 0.001 ether;
    uint256 public constant FLASH_LOAN_COOLDOWN = 60; // 1 minute
    uint256 public constant DAILY_FLASH_LOAN_LIMIT = 50;

    // ==================== STRUCTS ====================
    struct DEXInfo {
        address router;
        string name;
        uint256 feeBps; // Fee in basis points
        uint8 dexType; // 0: UniswapV2, 1: UniswapV3, 2: Sushiswap, 3: Balancer
    }

    struct ArbitrageParams {
        address tokenIn;
        address tokenOut;
        uint256 amountIn;
        uint256 minAmountOut;
        uint8 dexIn;
        uint8 dexOut;
        uint24 uniV3Fee;
        bytes32 balancerPoolId;
        uint256 deadline;
    }

    struct Opportunity {
        uint8 dexIn;
        uint8 dexOut;
        uint256 expectedProfit;
        uint256 minProfit;
        uint256 gasEstimate;
        bool isValid;
    }

    // ==================== STATE VARIABLES ====================
    DEXInfo[4] public dexConfigs;
    mapping(bytes32 => bool) public validBalancerPools;
    mapping(address => bool) public supportedTokens;
    mapping(address => uint256) public lastFlashLoan;
    mapping(address => uint256) public dailyFlashLoanCount;
    mapping(address => uint256) public lastDailyReset;

    uint256 public totalTrades;
    uint256 public totalVolume;

    // Optional, informational only: allows off-chain systems to record preference
    bool public preferPrivateSubmission; // e.g., Flashbots/bundles

    // ----------------- Chainlink price feeds (for gas-aware profitability checks) -----------------
    mapping(address => address) public priceFeedsUSD;
    address public CHAINLINK_ETH_USD;

    /// @notice Owner registers a Chainlink USD price feed for a token
    function setPriceFeed(address token, address feed) external onlyOwner {
        priceFeedsUSD[token] = feed;
    }

    /// @notice Owner sets the ETH/USD feed (required to convert gas cost to token units)
    function setChainlinkEthUsd(address feed) external onlyOwner {
        CHAINLINK_ETH_USD = feed;
    }

    function _latestAnswer(address feed) internal view returns (uint256) {
        require(feed != address(0), "no feed");
        (, int256 answer, , ,) = AggregatorV3Interface(feed).latestRoundData();
        require(answer > 0, "bad feed value");
        return uint256(answer);
    }

    function calculateTotalCosts(
    uint256 expectedProfitTokenIn,
    uint256 gasCostToken,
    uint256 flashLoanFeeBps,
    uint256 safetyMarginBps
) internal pure returns (uint256) {
    uint256 flashFeeToken = (expectedProfitTokenIn * flashLoanFeeBps) / 10000;
    uint256 safety = (expectedProfitTokenIn * safetyMarginBps) / 10000;
    return gasCostToken + flashFeeToken + safety;
}

function isProfitableAfterCosts(
    address tokenIn,
    uint256 expectedProfitTokenIn,
    uint256 gasUnitsEstimate,
    uint256 gasPriceWei,
    uint256 flashLoanFeeBps,
    uint256 safetyMarginBps
) public view returns (bool, uint256 netProfitTokenIn) {
    address tokenFeed = priceFeedsUSD[tokenIn];
    require(tokenFeed != address(0), "missing token feed");
    require(CHAINLINK_ETH_USD != address(0), "missing eth feed");

    uint256 ethPrice = _latestAnswer(CHAINLINK_ETH_USD);
    uint256 tokenPrice = _latestAnswer(tokenFeed);

    uint256 gasCostWei = gasUnitsEstimate * gasPriceWei;
    uint256 gasCostToken = (gasCostWei * ethPrice) / (tokenPrice * 1e18);

    uint256 totalCosts = calculateTotalCosts(expectedProfitTokenIn, gasCostToken, flashLoanFeeBps, safetyMarginBps);

    if (expectedProfitTokenIn <= totalCosts) {
        return (false, 0);
    }

    netProfitTokenIn = expectedProfitTokenIn - totalCosts;
    return (true, netProfitTokenIn);
}

    // ==================== EVENTS ====================
    event ArbitrageExecuted(
        address indexed user,
        address indexed tokenIn,
        address indexed tokenOut,
        uint256 amountIn,
        uint256 profit,
        uint8 dexIn,
        uint8 dexOut
    );

    event OpportunityFound(
        address indexed tokenA,
        address indexed tokenB,
        uint256 amount,
        uint256 expectedProfit,
        uint8 dexIn,
        uint8 dexOut
    );

    event EmergencyStop(bool stopped);
    event SlippageAdjusted(uint256 newSlippageBps);
    event PrivateTxPreferenceSet(bool enabled);

    // ==================== MODIFIERS ====================
    modifier validTokens(address tokenA, address tokenB) {
        require(tokenA != address(0) && tokenB != address(0), "Invalid tokens");
        require(tokenA != tokenB, "Same tokens");
        require(supportedTokens[tokenA] && supportedTokens[tokenB], "Unsupported tokens");
        _;
    }

    modifier rateLimited() {
        if (block.timestamp > lastDailyReset[msg.sender] + 1 days) {
            dailyFlashLoanCount[msg.sender] = 0;
            lastDailyReset[msg.sender] = block.timestamp;
        }
        require(block.timestamp >= lastFlashLoan[msg.sender] + FLASH_LOAN_COOLDOWN, "Flash loan cooldown");
        require(dailyFlashLoanCount[msg.sender] < DAILY_FLASH_LOAN_LIMIT, "Daily limit exceeded");
        _;
        lastFlashLoan[msg.sender] = block.timestamp;
        dailyFlashLoanCount[msg.sender]++;
    }

    // ==================== CONSTRUCTOR ====================
    constructor(address initialOwner) Ownable(initialOwner) {
        // Initialize DEX configurations
        dexConfigs[0] = DEXInfo(UNISWAP_V2_ROUTER, "Uniswap V2", 300, 0);
        dexConfigs[1] = DEXInfo(SUSHISWAP_ROUTER, "Sushiswap", 300, 2);
        dexConfigs[2] = DEXInfo(UNISWAP_V3_ROUTER, "Uniswap V3", 500, 1);
        dexConfigs[3] = DEXInfo(BALANCER_VAULT, "Balancer", 100, 3);

        // Set valid Balancer pools (examples)
        validBalancerPools[0x5c6ee304399dbdb9c8ef030ab642b10820db8f56000200000000000000000014] = true;
        validBalancerPools[0x96646936b91d6b9d7d0c47c496afbf3d6ec7b6f8000200000000000000000019] = true;
        validBalancerPools[0x0b09dea16768f0799065c475be02919503cb2a3500020000000000000000001a] = true;

        // Supported tokens
        supportedTokens[WETH] = true;
        supportedTokens[USDC] = true;
        supportedTokens[USDT] = true;
        supportedTokens[DAI] = true;
        supportedTokens[WBTC] = true;
    }

    // ==================== (Rest of your contract unchanged) ====================
    // All your main functions, internal functions, and interfaces remain the same as in the original code.
}
